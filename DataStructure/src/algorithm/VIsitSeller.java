package algorithm;

/**
 * @author wang.jl
 * 典型动态规划问题
 */
public class VIsitSeller {
    public int countPath(int[][] map, int n, int m) {

        int x1 = -1,y1 = -1;//经理的坐标
        int x2 = -1,y2 = -1;//商家的坐标
        //定位经理和商家的坐标
        for(int i = 0;i<n;i++){
            for(int j = 0; j<m;j++){
                if(map[i][j]==1){
                    x1 = j;
                    y1 = i;
                }else if(map[i][j]==2){
                    x2 = j;
                    y2 = i;
                }
            }
        }

        //只能选择一个方向
        int xto = x1>x2?-1:1;//根据经理和商家的方向判断向左还是向右走
        int yto = y1>y2?-1:1;//向上还是向下
        //动态规划的思想 map[y][x]记录着经理到x,y点最多的路程数
        //每一个点都记录着到这个点的最大路程数目

        //两层循环，每一次在y轴上走一步，就要记录所有x的情况
        for(int y = y1;y!=(y2+yto);y+=yto){
            for(int x = x1;x!=(x2+xto);x+=xto){

                //和出发点横坐标或纵坐标相等的点标记为1，因为只有一条路径可以到达
                if(y==y1||x==x1){
                    map[y][x] = 1;
                    continue;
                }
                //如果不是上述情况，那么应该有两个点可以到达这个点，记下那两个点的到达路程数
                map[y][x] = map[y-yto][x]+map[y][x-xto];
            }
        }
        return map[y2][x2];
    }
}

/**
 * 现在有一个城市销售经理，需要从公司出发，去拜访市内的商家，已知他的位置以及商家的位置，但是由于城市道路交通的原因，
 * 他只能在左右中选择一个方向，在上下中选择一个方向，现在问他有多少种方案到达商家地址。
 * 给定一个地图map及它的长宽n和m，其中1代表经理位置，2代表商家位置，-1代表不能经过的地区，0代表可以经过的地区，
 * 请返回方案数，保证一定存在合法路径。保证矩阵的长宽都小于等于10
 */
